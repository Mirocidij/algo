# Сумма в сортированном массиве

#two-pointers

#легко 

#яндекс

### Условие

Дан отсортированный массив `nums` и число `target`. Нужно вернуть позиции двух чисел, которые дают в сумме `target`, при этом ответ гарантированно присутствует и он единственный.

Нужно вернуть сначала меньший индекс, а потом больший (индексы не могут быть равными). При этом **индексация в массиве начинается с единицы, а не с нуля**.  

**ВАЖНО:** реши за `O(1)` по памяти

#### Примеры:

```
Ввод: nums = [-2,1,6,9,12], target=18
Вывод: [3,5]
Объяснение: 18 = 6 + 12, 6-ка имеет индекс 3, а 12 - индекс 5
```

```
Ввод: nums = [3,3,12], target=6
Вывод: [1,2]
```

#### Ограничения

- `len(nums) >= 2`

### Решение

```Java
import java.util.*;

public class Solution {
    public List<Integer> twoSum(List<Integer> nums, int target) {
        int p1 = 0, p2 = nums.size() - 1;
        int currSum = 0;
        while (p1 < p2) {
            currSum = nums.get(p1) + nums.get(p2);
            if (currSum == target) {
                return List.of(p1 + 1, p2 + 1);
            } else if (currSum > target) {
                p2--;
            } else {
                p1++;
            }
        }

        return List.of(-1, -1);
    }
}
```

Решено с первой попытки.

### Ошибки

Ошибок при сдаче не было.